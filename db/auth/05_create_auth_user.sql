CREATE OR REPLACE FUNCTION stat.get_fullname(IN in_fullname jsonb,IN mode integer DEFAULT 0)
    RETURNS text
    LANGUAGE 'plpgsql'
    IMMUTABLE
    PARALLEL UNSAFE
    COST 100
    
AS $BODY$
DECLARE
    lname text;
    fname text;
    mname text;
    result text default '';
BEGIN
    lname = coalesce(in_fullname->>'last_name', '');
    fname = coalesce(in_fullname->>'first_name', '');
    mname = coalesce(in_fullname->>'middle_name', '');
    result = lname;
    IF mode = 0 then
        IF fname > '' THEN 
            result = result || ' ' || fname;
            IF mname > '' THEN 
                result = result || ' ' || mname;
            END IF;
        END IF;
    ELSE
        IF fname > '' THEN
            IF mname > '' THEN 
                result = fname || ' ' || mname || ' ' || lname;
            ELSE
                result = fname || ' ' || lname;
            END IF;
        END IF;
    END IF;
    RETURN TRIM(result);
EXCEPTION
  WHEN others THEN RAISE EXCEPTION '%', sqlerrm;
END;
$BODY$;


-- Table: stat.auth_user

-- DROP TABLE stat.auth_user;

CREATE TABLE stat.auth_user
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    name character varying(50) COLLATE pg_catalog."default",
    full_name jsonb,
    caption text COLLATE pg_catalog."default",
    password character varying(100) COLLATE pg_catalog."default",
    type character varying(50) COLLATE pg_catalog."default",
    mobil_phone character varying(10) COLLATE pg_catalog."default",
    active boolean NOT NULL DEFAULT false,
    roles jsonb,
    organization_id bigint,
    avatar text COLLATE pg_catalog."default",
    deleted boolean NOT NULL DEFAULT false,
    thmb_avatar text COLLATE pg_catalog."default",
    CONSTRAINT auth_user_pkey PRIMARY KEY (id),
    CONSTRAINT auth_user_name_key UNIQUE (name),
    CONSTRAINT auth_user_organization_id_fkey FOREIGN KEY (organization_id)
        REFERENCES stat.organization (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT full_name_exists CHECK (full_name ? 'last_name'::text AND full_name ? 'first_name'::text AND full_name ? 'middle_name'::text),
    CONSTRAINT full_name_notnull CHECK ((full_name ->> 'last_name'::text) IS NOT NULL),
    CONSTRAINT type_is_valid CHECK (type::text = 'admin'::text OR type::text = 'user'::text)
)
WITH (
    OIDS = FALSE
)
TABLESPACE pg_default;

ALTER TABLE stat.auth_user
    OWNER to stat;

COMMENT ON TABLE stat.auth_user
    IS 'Таблица для хранения учетных данных пользователей';

COMMENT ON COLUMN stat.auth_user.id
    IS 'Уникальный ключ (id) для пользователя';

COMMENT ON COLUMN stat.auth_user.name
    IS 'Имя пользователя (логин)';

COMMENT ON COLUMN stat.auth_user.full_name
    IS 'ФИО пользователя в формате JSON';

COMMENT ON COLUMN stat.auth_user.caption
    IS 'Представление (описание) пользователя';

COMMENT ON COLUMN stat.auth_user.password
    IS 'Пароль пользователя в зашифрованном виде';

COMMENT ON COLUMN stat.auth_user.type
    IS 'Уровень доступа (тип пользователя). Принимает значения - администратор, пользователь';

COMMENT ON COLUMN stat.auth_user.mobil_phone
    IS 'Номер мобильного телефона пользователя в упакованном виде';

COMMENT ON COLUMN stat.auth_user.active
    IS 'Признак активности учетной записи, т.е. может ли пользователь входить в систему';

COMMENT ON COLUMN stat.auth_user.roles
    IS 'JSON массив ролей пользователя';

COMMENT ON COLUMN stat.auth_user.organization_id
    IS 'Ссылка на таблицу организаций к которой относится пользователь';
-- Index: auth_user_branch_btree_idx

-- DROP INDEX stat.auth_user_branch_btree_idx;

CREATE INDEX auth_user_branch_btree_idx
    ON stat.auth_user USING btree
    (mobil_phone COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
-- Index: auth_user_name_btree_idx

-- DROP INDEX stat.auth_user_name_btree_idx;

CREATE INDEX auth_user_name_btree_idx
    ON stat.auth_user USING btree
    (stat.normalize_string(name::text) COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;

COMMENT ON INDEX stat.auth_user_name_btree_idx
    IS 'Индекс для поиска по полному совпадению наименования в таблице должностей';
-- Index: auth_user_name_gin_idx

-- DROP INDEX stat.auth_user_name_gin_idx;

CREATE INDEX auth_user_name_gin_idx
    ON stat.auth_user USING gin
    (stat.normalize_string(get_fullname(full_name)) COLLATE pg_catalog."default" gin_trgm_ops)
    TABLESPACE pg_default;

COMMENT ON INDEX stat.auth_user_name_gin_idx
    IS 'Индекс для поиска по вхождению подстроки в наименование в таблице должностей';
-- Index: auth_user_page_navigation_btree_idx

-- DROP INDEX stat.auth_user_page_navigation_btree_idx;

CREATE INDEX auth_user_page_navigation_btree_idx
    ON stat.auth_user USING btree
    (stat.normalize_index_expression(full_name ->> 'last_name'::text, id, 50) COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;